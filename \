#include <GL/glew.h>
 #include <GLFW/glfw3.h>
#include  <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>

#include "Geometry.h"
#include "Shader.h"
#include <iostream>
#include  "glHelper.h"

// POINT
Point::Point():
    Point::Point(glm::vec2(0.0f,0.0f))
{
    //std::cout << "Point()\n";
    //std::cout << "\t\n";
}
Point::Point(glm::vec2 pos):
    Point::Point(glm::vec3(pos,0.0f))
{
    //std::cout << "Point(glm::vec2 pos)\n";
    //std::cout << "\t(" << pos.x << ", " << pos.y << ")\n";
}
Point::Point(glm::vec2 pos, float col):
    Point::Point(glm::vec3(pos,0.0f),col)
{
    //std::cout << "Point(glm::vec2 pos, float col)\n";
    //std::cout << "\t(" << pos.x << ", " << pos.y << ")\n";
    //std::cout << "\t(" << col << ")\n";
}
Point::Point(glm::vec2 pos, glm::vec3 col):
    Point::Point(glm::vec3(pos,0.0f),col)
{
    //std::cout << "Point(glm::vec2 pos, glm::vec3 col)\n";
    //std::cout << "\t(" << pos.x << ", " << pos.y << ")\n";
    //std::cout << "\t(" << col.x << ", " << col.y << ", " <<  col.z << ")\n";
}
Point::Point(glm::vec2 pos, glm::vec4 col):
    Point::Point(glm::vec3(pos,0.0f),col)
{
    //std::cout << "Point(glm::vec2 pos, glm::vec4 col)\n";
    //std::cout << "\t(" << pos.x << ", " << pos.y << ")\n";
    //std::cout << "\t(" << col.x << ", " << col.y << ", " <<  col.z << ", " << col.w << ")\n";
}
Point::Point(glm::vec3 pos):
    Point::Point(pos,1.0f)
{
    //std::cout << "Point(glm::vec3 pos)\n";
    //std::cout << "\t(" << pos.x << ", " << pos.y << ", " << pos.z << ")\n";
}
Point::Point(glm::vec3 pos, float col):
    Point::Point(pos,glm::vec3(col,col,col))
{
    //std::cout << "Point(glm::vec3 pos, float col)\n";
    //std::cout << "\t(" << pos.x << ", " << pos.y << ", " << pos.z << ")\n";
    //std::cout << "\t(" << col << ")\n";
}
Point::Point(glm::vec3 pos, glm::vec3 col):
    Point::Point(pos,glm::vec4(col,1.0f))
{
    //std::cout << "Point(glm::vec3 pos, glm::vec3 col)\n";
    //std::cout << "\t(" << pos.x << ", " << pos.y << ", " << pos.z << ")\n";
    //std::cout << "\t(" << col.x << ", " << col.y << ", " <<  col.z << ")\n";
}
Point::Point(glm::vec3 pos, glm::vec4 col) :
    x(pos.x),y(pos.y),z(pos.z),r(col.x),g(col.y),b(col.z),a(col.w)
{
    //std::cout << "Point(glm::vec3 pos, glm::vec4 col) \n";
    //std::cout << "\t(" << pos.x << ", " << pos.y << ", " << pos.z << ")\n";
    //std::cout << "\t(" << col.x << ", " << col.y << ", " <<  col.z << ", " << col.w << ")\n";
}

Point& Point::operator=(const Point& other){
    if((*this) != other){
        x = other.x;
        y = other.y;
        z = other.z;
        r = other.r;
        g = other.g;
        b = other.b;
        a = other.a;
    }
    
    return *this;
}
bool Point::operator<(const Point& other){
    pLine(__FILE__,__LINE__);
    if(x < other.x) return true;
    pLine(__FILE__,__LINE__);
    if(x > other.x) return false;
    pLine(__FILE__,__LINE__);
    if(y < other.y) return true;
    pLine(__FILE__,__LINE__);
    return false;
}
bool Point::operator<=(const Point& other){
    if(x <= other.x) return true;
    if(x > other.x) return false;
    if(y <= other.y) return true;
    return false;
}
bool Point::operator>(const Point& other){
    if(x > other.x) return true;
    if(x < other.x) return false;
    if(y > other.y) return true;
    return false;
}
bool Point::operator>=(const Point& other){
    if(x >= other.x) return true;
    if(x < other.x) return false;
    if(y >= other.y) return true;
    return false;
}

Point Point::operator+(Point& other){
    pLine(__FILE__,__LINE__);
    std::cout << "test\n";
    std::cout << x << "\n";
    std::cout << other.getX() << "\n";
    std::cout << x+other.getX() << " ";
    std::cout << y+other.getY() << " ";
    std::cout << z+other.getZ() << "\n";
    glm::vec3 pos = glm::vec3(x+other.x,y+other.y,z+other.z);
    pLine(__FILE__,__LINE__);
    glm::vec4 col = glm::vec4((r+other.r)/2.0f,(g+other.g)/2.0f,(b+other.b)/2.0f,(a+other.a)/2.0f);
    pLine(__FILE__,__LINE__);
    Point p(pos, col);
    pLine(__FILE__,__LINE__);
    p.print();

    return p;
}
Point Point::operator-(const Point& other){
    return Point(
            glm::vec3(x-other.x,y-other.y,z-other.z),
            glm::vec3((r+other.r)/2.0f,(g+other.g)/2.0f,(b+other.b)/2.0f));
}
Point Point::operator*(float scalar){
    return Point(
            glm::vec3(x*scalar,y*scalar,z*scalar),
            glm::vec4(r,g,b,a));
}
Point Point::operator/(float scalar){
    return (*this)*(1/scalar);
}

bool Point::operator==(const Point& other){
    return x == other.x && y == other.y && z == other.z && r == other.r && g == other.g && b == other.b && a == other.a;
}

bool Point::operator!=(const Point& other){
    return !(*this == other);
}

float Point::getX(){
    pLine(__FILE__,__LINE__);
    std::cout << x << "\n";
    return x;
}
float Point::getY(){
    return y;
}
float Point::getZ(){
    return z;
}
float Point::getR(){
    return r;
}
float Point::getG(){
    return g;
}
float Point::getB(){
    return b;
}
float Point::getA(){
    return a;
}
glm::vec3 Point::posVec(){
    pLine(__FILE__,__LINE__);
    return glm::vec3(x,y,z);
}
float* Point::getData(){
    data[0] = x;
    data[1] = y;
    data[2] = z;
    data[3] = r;
    data[4] = g;
    data[5] = b;
    data[6] = a;

    return data;
}
void Point::bind(unsigned int& VAO, unsigned int& VBO){
    glBindVertexArray(VAO);
    glBindBuffer(GL_ARRAY_BUFFER,VBO);

    getData();

    glBufferData(GL_ARRAY_BUFFER,sizeof(data),data,GL_STATIC_DRAW);
    glVertexAttribPointer(0,3,GL_FLOAT,GL_FALSE,7*sizeof(float),(void*)0);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(1,4,GL_FLOAT,GL_FALSE,7*sizeof(float),(void*)(3*sizeof(float)));
    glEnableVertexAttribArray(1);
    glBindBuffer(GL_ARRAY_BUFFER,0);
    glBindVertexArray(0);
    glEnableVertexAttribArray(0);
}

void Point::print(){
    std::cout << "(" << x << ", " << y << ", " << z << ")\n";
    std::cout << "\tR: "<< r << " G: " << g << " B: " << b << " A: " << a << "\n";
}

// LINE
Line::Line() : Line::Line(Point(),Point()) {}
Line::Line(Point _p1, Point _p2) : p1(_p1), p2(_p2){}
Line& Line::operator=(const Line&  other){
    if(*this != other){
        p1 = other.p1;
        p2 = other.p2;
    }

    return *this;
}

bool Line::operator<(Line& other){
    return getCenter() < other.getCenter();
}
bool Line::operator>(Line& other){
    return getCenter() > other.getCenter();
}
bool Line::operator<=(Line& other){
    return getCenter() <= other.getCenter();
}
bool Line::operator>=(Line& other){
    return getCenter() >= other.getCenter();
}

bool Line::operator==(const Line& other){
    return p1 == other.p1 && p2 == other.p2;
}
bool Line::operator!=(const Line& other){
    return !(*this == other);
}
float* Line::getData(){
    data[0] = p1.getX();
    data[1] = p1.getY();
    data[2] = p1.getZ();
    data[3] = p1.getR();
    data[4] = p1.getG();
    data[5] = p1.getB();
    data[6] = p1.getA();

    data[7] = p2.getX();
    data[8] = p2.getY();
    data[9] = p2.getZ();
    data[10] = p2.getR();
    data[11] = p2.getG();
    data[12] = p2.getB();
    data[13] = p2.getA();

    return data;
}
void Line::bind(unsigned int& VAO, unsigned int& VBO){
    glBindVertexArray(VAO);
    glBindBuffer(GL_ARRAY_BUFFER,VBO);

    getData();

    glBufferData(GL_ARRAY_BUFFER,sizeof(data),data,GL_STATIC_DRAW);
    glVertexAttribPointer(0,3,GL_FLOAT,GL_FALSE,7*sizeof(float),(void*)0);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(1,4,GL_FLOAT,GL_FALSE,7*sizeof(float),(void*)(3*sizeof(float)));
    glEnableVertexAttribArray(1);

    glBindBuffer(GL_ARRAY_BUFFER,0);
    glBindVertexArray(0);
    glEnableVertexAttribArray(0);
}

void Line::draw(unsigned int& VAO, unsigned int& VBO, Shader& shader){

    bind(VAO,VBO);
    shader.use();
    glBindVertexArray(VAO);
    glBindBuffer(GL_ARRAY_BUFFER,VBO); // ?
    glLineWidth(5.0f);
    glDrawArrays(GL_LINES,0,2);
    glBindVertexArray(0);

    GLenum err;
    while ((err = glGetError()) != GL_NO_ERROR) {
        std::cerr << "OpenGL error: " << err << "\n";
    }
}

Point Line::getCenter(){
    Point tp = Point(glm::vec3(0,0,0));
    tp.print();
    tp = tp+p1;
    tp.print();
    return Point(((p1+p2)/2.0f).posVec());
}

void Line::print(){
    std::cout << "p1\n\t";
    p1.print();
    std::cout << "p2\n\t";
    p2.print();
}

// Line Node
LineNode::LineNode():
    LineNode::LineNode(Line(),NULL)
{
    pLine(__FILE__,__LINE__);
}
LineNode::LineNode(const Line& _data): 
    LineNode::LineNode(_data, NULL)
{
    pLine(__FILE__,__LINE__);
}
LineNode::LineNode(const Line& _data, LineNode* _parent)//:
    //data(_data), parent(_parent)
{
    pLine(__FILE__,__LINE__);
    data = _data;
    pLine(__FILE__,__LINE__);
    parent = _parent;
    pLine(__FILE__,__LINE__);

}

LineNode* LineNode::add(Line& _data){
    pLine(__FILE__,__LINE__);
    if(_data < data){
        if(left == NULL){
            left = new LineNode(_data,this);
            return left;
        }
        else return left->add(_data);
    }else{
        if(right == NULL){
            right = new LineNode(_data,this);
            return right;
        }
        else return right->add(_data);
    }
}

Line& LineNode::getData(){
    return  data;
}

LineNode* LineNode::find(Line& _data){
    if(data ==  _data) return this;
    if(_data<data){
        if(left == NULL) return NULL;
        return left->find(_data);
    }
    if(_data>data){
        if(right == NULL) return NULL;
        return right->find(_data);
    }
    return NULL;
}

LineNode* LineNode::getLeft(){
    return left;
}
LineNode* LineNode::getRight(){
    return right;
}
